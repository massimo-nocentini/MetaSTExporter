{	"classes" : {		"ExternalBrowser" : {			"hash" : 3143936,			"definition" : "ComposablePresenter subclass: #ExternalBrowser\r\tinstanceVariableNames: 'classes packages protocols selectors method showClassSide model'\r\tclassVariableNames: ''\r\tpackage: 'Tool-ExternalBrowser-Browsers'",			"comment" : [				"Browser the current image:",				"",				"\tExternalBrowser openOn: Smalltalk image.",				"",				"Browse a FileOut",				"",				"\t| internalStream |",				"\tinternalStream := (String new: 1000) writeStream.",				"\tSystemOrganization ",				"\t\tfileOutCategory: 'Tool-ExternalBrowser'",				"\t\ton: internalStream.",				"\tExternalBrowser browseStream: internalStream contents readStream."			],			"category" : "Tool-ExternalBrowser-Browsers"		},		"PragmaCollector class" : {			"hash" : 1471744,			"definition" : "PragmaCollector class\r\tinstanceVariableNames: ''",			"comment" : [				"Note: In most cases it is better to use the class side methods of Pragma instead.",				"",				"PragmaCollector is useful if a client needs to be notified if pragmas are added or removed.",				"If you do not store the PragmaCollector instance, you most likely can just use the API of Pragma directly.",				"",				"A PragmaCollector is used in order to collect some Pragma instances. A PragmaCollector makes use of SystemChangeNotifier event notifications in order to maintain its contents up-to-date according to its filter: when a method is added, removed or updated, if the method is defined with a pragma which is acceptable according to its filter, then the collector contents is updated. A PragmaCollector makes use of an announcer in order to notify all registered listeners when a pragma is added, removed or updated. A PragmaAnnouncement is announced when a Pragma is added, removed or updated. Corresponding announcement classes are, respectiveley, PragmaAdded, PragmaRemoved and PragmaUpdated. ",				"",				"The filter is applied to all Pragmas or (faster) pragmas with the selectors defined by #selectors:.",				"",				"Explore the result of the expression below. In the collected instance variable should be stored all pragmas of the system:",				"---------------------------",				"(PragmaCollector filter: [:pragma | true]) reset",				"---------------------------",				"",				"In the following example, collected pragma are thoses with the 'primitive:' selector (<primitive:>)",				"---------------------------",				"(PragmaCollector filter: [:prg | prg selector = 'primitive:']) reset.",				"---------------------------",				"",				"In this case it is faster to specify selectors via #selector, as this avoids to iterate over all Pragmas of the system:",				"",				"---------------------------",				"(PragmaCollector selectors: #(primitive:)) reset",				"---------------------------",				"",				"We can specify both the selectors and an additional filter, e.g. filter for all Pragmas named primitive: in methods that have one Argument:",				" ",				"---------------------------",				"(PragmaCollector ",				"\tselectors: #(primitive:) ",				"\tfilter: [:prg | prg methodSelector numArgs = 1] ) reset",				"---------------------------",				"",				"Instance Variables\t",				"\tannouncer:\t\t<Announcer>\t",				"\tcollected:\t\t<Collection>",				"\tfilter:\t\t\t<Block or MessageSend>",				"\tselector:      <Array of symbols>",				"\t\t\t\t",				"announcer",				"\tthe announcer which is used to announce the adding, the removing or the updating of a method with an acceptable pragma declaration",				"",				"collected\t\t",				"\tthe current collection of Pragma",				"\t",				"filter",				"\ta block or a message send which is used in order to filter the pragma. This is a one argument valuable. When evaluated, the candidate pragam is passed as argument and the result must be a boolean. ",				"\t"			],			"category" : "PragmaCollector-Base"		},		"ClyMessageBasedQuery" : {			"hash" : 4502272,			"definition" : "ClyMethodQuery subclass: #ClyMessageBasedQuery\r\tinstanceVariableNames: 'selectors'\r\tclassVariableNames: ''\r\tpackage: 'Calypso-SystemQueries-Queries'",			"comment" : [				"I am a root of hierarchy of method queries which uses set of selectors to filter methods.",				"",				"My instances can be created using following methods:",				"",				"\tClyMessageSenders of: #selector.",				"\tClyMessageImplementors of: #selector from: aScope.",				"\tClyMessageSenders ofAny: #(selector1 selector2).",				"\tClyMessageImplementors ofAny: #(selector1 selector2) from: aScope.",				"",				"I provide suitable printing methods and correct comparison implementation.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tselectors:\t\t<Array of<Symbol>>"			],			"category" : "Calypso-SystemQueries-Queries"		},		"RBPullUpMethodRefactoring" : {			"hash" : 3284736,			"definition" : "RBMethodRefactoring subclass: #RBPullUpMethodRefactoring\r\tinstanceVariableNames: 'removeDuplicates selectors targetSuperclass'\r\tclassVariableNames: ''\r\tpackage: 'Refactoring-Core-Refactorings'",			"comment" : [				"I am a refactoring for moving a method up to the superclass. ",				"",				"My precondition verify that this method does not refere to instance variables not accessible in the superclass. And this method does not sends a super message that is defined in the superclass.",				"If the method already exists and the superclass is abstract or not referenced anywhere, replace that implementation and push down the old method to all other existing subclasses.",				"",				""			],			"category" : "Refactoring-Core-Refactorings"		},		"CoMockClass" : {			"hash" : 2867456,			"definition" : "Object subclass: #CoMockClass\r\tinstanceVariableNames: 'instanceVariables selectors classVariables superclass methodDictionary sharedPools'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Tests-Core'",			"comment" : [				"I am a mock class used in the tests to get the information."			],			"category" : "HeuristicCompletion-Tests-Core"		},		"RBPushDownMethodRefactoring" : {			"hash" : 3285248,			"definition" : "RBMethodRefactoring subclass: #RBPushDownMethodRefactoring\r\tinstanceVariableNames: 'selectors'\r\tclassVariableNames: ''\r\tpackage: 'Refactoring-Core-Refactorings'",			"comment" : [				"I am a refactoring for moving a method down to all direct subclasses.",				"",				"My preconditions verify that this method isn't refered  as a super send in the subclass. And the class defining this method is abstract or not referenced anywhere.",				""			],			"category" : "Refactoring-Core-Refactorings"		},		"PragmaCollector" : {			"hash" : 1472000,			"definition" : "Model subclass: #PragmaCollector\r\tinstanceVariableNames: 'collected filter announcing selectors'\r\tclassVariableNames: ''\r\tpackage: 'PragmaCollector-Base'",			"comment" : [				"Note: In most cases it is better to use the class side methods of Pragma instead.",				"",				"PragmaCollector is useful if a client needs to be notified if pragmas are added or removed.",				"If you do not store the PragmaCollector instance, you most likely can just use the API of Pragma directly.",				"",				"A PragmaCollector is used in order to collect some Pragma instances. A PragmaCollector makes use of SystemChangeNotifier event notifications in order to maintain its contents up-to-date according to its filter: when a method is added, removed or updated, if the method is defined with a pragma which is acceptable according to its filter, then the collector contents is updated. A PragmaCollector makes use of an announcer in order to notify all registered listeners when a pragma is added, removed or updated. A PragmaAnnouncement is announced when a Pragma is added, removed or updated. Corresponding announcement classes are, respectiveley, PragmaAdded, PragmaRemoved and PragmaUpdated. ",				"",				"The filter is applied to all Pragmas or (faster) pragmas with the selectors defined by #selectors:.",				"",				"Explore the result of the expression below. In the collected instance variable should be stored all pragmas of the system:",				"---------------------------",				"(PragmaCollector filter: [:pragma | true]) reset",				"---------------------------",				"",				"In the following example, collected pragma are thoses with the 'primitive:' selector (<primitive:>)",				"---------------------------",				"(PragmaCollector filter: [:prg | prg selector = 'primitive:']) reset.",				"---------------------------",				"",				"In this case it is faster to specify selectors via #selector, as this avoids to iterate over all Pragmas of the system:",				"",				"---------------------------",				"(PragmaCollector selectors: #(primitive:)) reset",				"---------------------------",				"",				"We can specify both the selectors and an additional filter, e.g. filter for all Pragmas named primitive: in methods that have one Argument:",				" ",				"---------------------------",				"(PragmaCollector ",				"\tselectors: #(primitive:) ",				"\tfilter: [:prg | prg methodSelector numArgs = 1] ) reset",				"---------------------------",				"",				"Instance Variables\t",				"\tannouncer:\t\t<Announcer>\t",				"\tcollected:\t\t<Collection>",				"\tfilter:\t\t\t<Block or MessageSend>",				"\tselector:      <Array of symbols>",				"\t\t\t\t",				"announcer",				"\tthe announcer which is used to announce the adding, the removing or the updating of a method with an acceptable pragma declaration",				"",				"collected\t\t",				"\tthe current collection of Pragma",				"\t",				"filter",				"\ta block or a message send which is used in order to filter the pragma. This is a one argument valuable. When evaluated, the candidate pragam is passed as argument and the result must be a boolean. ",				"\t"			],			"category" : "PragmaCollector-Base"		},		"MetaSTExporter" : {			"hash" : 2636800,			"definition" : "Object subclass: #MetaSTExporter\r\tinstanceVariableNames: 'selectors'\r\tclassVariableNames: ''\r\tpackage: 'MetaSTExporter'",			"comment" : [				"I am a prototype of a documentation exporter (or builder) that generate a structured representation of the concepts catched and written for classes and messages.",				"",				"## Example",				"",				"After a discussion with Richard Uttner, we agreed to investigate the following approach:",				"",				"Directory Realog documentation:",				"\t- Realog.json 'this file contains a kind of `db` for all the collected topics.'",				"\t- Realog_state.markup 'this file will contain the class comment.'",				"\t- Realog_State_walk.markup 'this file is generated because the pragma `<doc: 'Realog' topic: #(State walk) > has been encontered.'",				"\t- Realog_State_walk_inDictionary.markup 'this file is generated because the pragma `<doc: 'Realog' topic: #(State walk inDictionary) > has been encontered.'",				"",				"In each markup file the corresponding chunk of code will be added to the bottom, both ",				"at the first creation and after each change to the source code in the Smalltalk image. ",				"For instance:",				"",				"[[[ ",				"walk: anObj",				"...",				"]]]"			],			"category" : "MetaSTExporter"		}	},	"messages" : {		"selectors:" : {			"senders" : [				"BaselineOfMetaSTExporter>>#scriptExportCoreMessagesForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"BaselineOfMicroKanren>>#scriptExportSexpTestsForDoc",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc",				"BaselineOfMicroKanren>>#scriptExportCoreMessagesForDoc",				"BaselineOfMicroKanren>>#scriptExportCoreTestsForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverPredicatesForDoc",				"ClyMessageBasedQuery class>>#ofAny:",				"CoBasicCompletionTest>>#setUp",				"CoRepeatedHierarchyImplementedSelectorsFetcherTest>>#setUp",				"PragmaCollector class>>#selectors:",				"PragmaCollector class>>#selectors:filter:",				"RBPushDownPreviewPresenter>>#accept",				"RBPushUpPreviewPresenter>>#accept",				"SettingTree>>#acceptableKeywords:"			],			"implementors" : {				"CoMockClass" : {					"sourceCode" : [						"selectors: aCollection",						"",						"\t\"Install nil methods just for compatibility\"",						"",						"\taCollection do: [ :k | methodDictionary at: k put: nil ]"					],					"body" : [						"aCollection do: [ :k | methodDictionary at: k put: nil ]"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [						"Install nil methods just for compatibility"					],					"hash" : 20700975,					"argumentNames" : [						"aCollection"					]				},				"RBPushDownMethodRefactoring" : {					"sourceCode" : [						"selectors: aList",						"",						"\tselectors := aList"					],					"body" : [						"selectors := aList"					],					"isTestMethod" : false,					"category" : "transforming",					"comment" : [ ],					"hash" : 21118361,					"argumentNames" : [						"aList"					]				},				"MetaSTExporter" : {					"sourceCode" : [						"selectors: anObject",						"",						"\tselectors := anObject"					],					"body" : [						"selectors := anObject"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20469910,					"argumentNames" : [						"anObject"					]				},				"ExternalBrowser" : {					"sourceCode" : [						"selectors: anObject",						"",						"\tselectors := anObject"					],					"body" : [						"selectors := anObject"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20977105,					"argumentNames" : [						"anObject"					]				},				"ClyMessageBasedQuery" : {					"sourceCode" : [						"selectors: anObject",						"",						"\tselectors := anObject"					],					"body" : [						"selectors := anObject"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 22335384,					"argumentNames" : [						"anObject"					]				},				"RBPullUpMethodRefactoring" : {					"sourceCode" : [						"selectors: aList",						"",						"\tselectors := aList"					],					"body" : [						"selectors := aList"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 21117850,					"argumentNames" : [						"aList"					]				},				"PragmaCollector class" : {					"sourceCode" : [						"selectors: anArray",						"",						"\t\"Create a PragmaCollector that looks for Pragmas with the specified selectors\"",						"",						"\t^ self new selectors: anArray"					],					"body" : [						"^ self new selectors: anArray"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [						"Create a PragmaCollector that looks for Pragmas with the specified selectors"					],					"hash" : 19305021,					"argumentNames" : [						"anArray"					]				},				"PragmaCollector" : {					"sourceCode" : [						"selectors: anArray",						"",						"\tselectors := anArray"					],					"body" : [						"selectors := anArray"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 19305115,					"argumentNames" : [						"anArray"					]				}			}		},		"exportWithRepositoryPath:ofPackage:" : {			"senders" : [				"BaselineOfMetaSTExporter>>#scriptExportCoreMessagesForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"BaselineOfMicroKanren>>#scriptExportSexpTestsForDoc",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc",				"BaselineOfMicroKanren>>#scriptExportCoreMessagesForDoc",				"BaselineOfMicroKanren>>#scriptExportCoreTestsForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverPredicatesForDoc"			],			"implementors" : {				"MetaSTExporter" : {					"sourceCode" : [						"exportWithRepositoryPath: aBlock ofPackage: aPackage",						"",						"\t| aPath |",						"\taPath := aBlock value:",						"\t\t         (IceRepository registeredRepositoryIncludingPackage:",						"\t\t\t          aPackage) repositoryDirectory asPath.",						"\t^ self exportInFileReference: aPath asFileReference"					],					"body" : [						"| aPath |",						"aPath := aBlock value:",						"\t         (IceRepository registeredRepositoryIncludingPackage:",						"\t\t          aPackage) repositoryDirectory asPath.",						"^ self exportInFileReference: aPath asFileReference"					],					"isTestMethod" : false,					"category" : "export",					"comment" : [ ],					"hash" : 37772572,					"argumentNames" : [						"aBlock",						"aPackage"					]				}			}		}	}}