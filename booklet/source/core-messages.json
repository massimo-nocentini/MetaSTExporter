{	"classes" : {		"PragmaCollector" : {			"hash" : 1472000,			"definition" : "Model subclass: #PragmaCollector\r\tinstanceVariableNames: 'collected filter announcing selectors'\r\tclassVariableNames: ''\r\tpackage: 'PragmaCollector-Base'",			"comment" : [				"Note: In most cases it is better to use the class side methods of Pragma instead.",				"",				"PragmaCollector is useful if a client needs to be notified if pragmas are added or removed.",				"If you do not store the PragmaCollector instance, you most likely can just use the API of Pragma directly.",				"",				"A PragmaCollector is used in order to collect some Pragma instances. A PragmaCollector makes use of SystemChangeNotifier event notifications in order to maintain its contents up-to-date according to its filter: when a method is added, removed or updated, if the method is defined with a pragma which is acceptable according to its filter, then the collector contents is updated. A PragmaCollector makes use of an announcer in order to notify all registered listeners when a pragma is added, removed or updated. A PragmaAnnouncement is announced when a Pragma is added, removed or updated. Corresponding announcement classes are, respectiveley, PragmaAdded, PragmaRemoved and PragmaUpdated. ",				"",				"The filter is applied to all Pragmas or (faster) pragmas with the selectors defined by #selectors:.",				"",				"Explore the result of the expression below. In the collected instance variable should be stored all pragmas of the system:",				"---------------------------",				"(PragmaCollector filter: [:pragma | true]) reset",				"---------------------------",				"",				"In the following example, collected pragma are thoses with the 'primitive:' selector (<primitive:>)",				"---------------------------",				"(PragmaCollector filter: [:prg | prg selector = 'primitive:']) reset.",				"---------------------------",				"",				"In this case it is faster to specify selectors via #selector, as this avoids to iterate over all Pragmas of the system:",				"",				"---------------------------",				"(PragmaCollector selectors: #(primitive:)) reset",				"---------------------------",				"",				"We can specify both the selectors and an additional filter, e.g. filter for all Pragmas named primitive: in methods that have one Argument:",				" ",				"---------------------------",				"(PragmaCollector ",				"\tselectors: #(primitive:) ",				"\tfilter: [:prg | prg methodSelector numArgs = 1] ) reset",				"---------------------------",				"",				"Instance Variables\t",				"\tannouncer:\t\t<Announcer>\t",				"\tcollected:\t\t<Collection>",				"\tfilter:\t\t\t<Block or MessageSend>",				"\tselector:      <Array of symbols>",				"\t\t\t\t",				"announcer",				"\tthe announcer which is used to announce the adding, the removing or the updating of a method with an acceptable pragma declaration",				"",				"collected\t\t",				"\tthe current collection of Pragma",				"\t",				"filter",				"\ta block or a message send which is used in order to filter the pragma. This is a one argument valuable. When evaluated, the candidate pragam is passed as argument and the result must be a boolean. ",				"\t"			],			"category" : "PragmaCollector-Base"		},		"PragmaCollector class" : {			"hash" : 1471744,			"definition" : "PragmaCollector class\r\tinstanceVariableNames: ''",			"comment" : [				"Note: In most cases it is better to use the class side methods of Pragma instead.",				"",				"PragmaCollector is useful if a client needs to be notified if pragmas are added or removed.",				"If you do not store the PragmaCollector instance, you most likely can just use the API of Pragma directly.",				"",				"A PragmaCollector is used in order to collect some Pragma instances. A PragmaCollector makes use of SystemChangeNotifier event notifications in order to maintain its contents up-to-date according to its filter: when a method is added, removed or updated, if the method is defined with a pragma which is acceptable according to its filter, then the collector contents is updated. A PragmaCollector makes use of an announcer in order to notify all registered listeners when a pragma is added, removed or updated. A PragmaAnnouncement is announced when a Pragma is added, removed or updated. Corresponding announcement classes are, respectiveley, PragmaAdded, PragmaRemoved and PragmaUpdated. ",				"",				"The filter is applied to all Pragmas or (faster) pragmas with the selectors defined by #selectors:.",				"",				"Explore the result of the expression below. In the collected instance variable should be stored all pragmas of the system:",				"---------------------------",				"(PragmaCollector filter: [:pragma | true]) reset",				"---------------------------",				"",				"In the following example, collected pragma are thoses with the 'primitive:' selector (<primitive:>)",				"---------------------------",				"(PragmaCollector filter: [:prg | prg selector = 'primitive:']) reset.",				"---------------------------",				"",				"In this case it is faster to specify selectors via #selector, as this avoids to iterate over all Pragmas of the system:",				"",				"---------------------------",				"(PragmaCollector selectors: #(primitive:)) reset",				"---------------------------",				"",				"We can specify both the selectors and an additional filter, e.g. filter for all Pragmas named primitive: in methods that have one Argument:",				" ",				"---------------------------",				"(PragmaCollector ",				"\tselectors: #(primitive:) ",				"\tfilter: [:prg | prg methodSelector numArgs = 1] ) reset",				"---------------------------",				"",				"Instance Variables\t",				"\tannouncer:\t\t<Announcer>\t",				"\tcollected:\t\t<Collection>",				"\tfilter:\t\t\t<Block or MessageSend>",				"\tselector:      <Array of symbols>",				"\t\t\t\t",				"announcer",				"\tthe announcer which is used to announce the adding, the removing or the updating of a method with an acceptable pragma declaration",				"",				"collected\t\t",				"\tthe current collection of Pragma",				"\t",				"filter",				"\ta block or a message send which is used in order to filter the pragma. This is a one argument valuable. When evaluated, the candidate pragam is passed as argument and the result must be a boolean. ",				"\t"			],			"category" : "PragmaCollector-Base"		},		"ExternalBrowser" : {			"hash" : 3143936,			"definition" : "ComposablePresenter subclass: #ExternalBrowser\r\tinstanceVariableNames: 'classes packages protocols selectors method showClassSide model'\r\tclassVariableNames: ''\r\tpackage: 'Tool-ExternalBrowser-Browsers'",			"comment" : [				"Browser the current image:",				"",				"\tExternalBrowser openOn: Smalltalk image.",				"",				"Browse a FileOut",				"",				"\t| internalStream |",				"\tinternalStream := (String new: 1000) writeStream.",				"\tSystemOrganization ",				"\t\tfileOutCategory: 'Tool-ExternalBrowser'",				"\t\ton: internalStream.",				"\tExternalBrowser browseStream: internalStream contents readStream."			],			"category" : "Tool-ExternalBrowser-Browsers"		},		"CoMockClass" : {			"hash" : 2867456,			"definition" : "Object subclass: #CoMockClass\r\tinstanceVariableNames: 'instanceVariables selectors classVariables superclass methodDictionary sharedPools'\r\tclassVariableNames: ''\r\tpackage: 'HeuristicCompletion-Tests-Core'",			"comment" : [				"I am a mock class used in the tests to get the information."			],			"category" : "HeuristicCompletion-Tests-Core"		},		"MetaSTExporter" : {			"hash" : 2636800,			"definition" : "Object subclass: #MetaSTExporter\r\tinstanceVariableNames: 'selectors'\r\tclassVariableNames: ''\r\tpackage: 'MetaSTExporter'",			"comment" : [				"I am a prototype of a documentation exporter (or builder) that generate a structured representation of the concepts catched and written for classes and messages.",				"",				"## Example",				"",				"After a discussion with Richard Uttner, we agreed to investigate the following approach:",				"",				"Directory Realog documentation:",				"\t- Realog.json 'this file contains a kind of `db` for all the collected topics.'",				"\t- Realog_state.markup 'this file will contain the class comment.'",				"\t- Realog_State_walk.markup 'this file is generated because the pragma `<doc: 'Realog' topic: #(State walk) > has been encontered.'",				"\t- Realog_State_walk_inDictionary.markup 'this file is generated because the pragma `<doc: 'Realog' topic: #(State walk inDictionary) > has been encontered.'",				"",				"In each markup file the corresponding chunk of code will be added to the bottom, both ",				"at the first creation and after each change to the source code in the Smalltalk image. ",				"For instance:",				"",				"[[[ ",				"walk: anObj",				"...",				"]]]"			],			"category" : "MetaSTExporter"		},		"BaselineOfMicroKanren" : {			"hash" : 2514688,			"definition" : "BaselineOf subclass: #BaselineOfMicroKanren\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'BaselineOfMicroKanren'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "BaselineOfMicroKanren"		},		"BaselineOfMetaSTExporter" : {			"hash" : 2850048,			"definition" : "BaselineOf subclass: #BaselineOfMetaSTExporter\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'BaselineOfMetaSTExporter'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "BaselineOfMetaSTExporter"		},		"RBPullUpMethodRefactoring" : {			"hash" : 3284736,			"definition" : "RBMethodRefactoring subclass: #RBPullUpMethodRefactoring\r\tinstanceVariableNames: 'removeDuplicates selectors targetSuperclass'\r\tclassVariableNames: ''\r\tpackage: 'Refactoring-Core-Refactorings'",			"comment" : [				"I am a refactoring for moving a method up to the superclass. ",				"",				"My precondition verify that this method does not refere to instance variables not accessible in the superclass. And this method does not sends a super message that is defined in the superclass.",				"If the method already exists and the superclass is abstract or not referenced anywhere, replace that implementation and push down the old method to all other existing subclasses.",				"",				""			],			"category" : "Refactoring-Core-Refactorings"		},		"RBPushDownMethodRefactoring" : {			"hash" : 3285248,			"definition" : "RBMethodRefactoring subclass: #RBPushDownMethodRefactoring\r\tinstanceVariableNames: 'selectors'\r\tclassVariableNames: ''\r\tpackage: 'Refactoring-Core-Refactorings'",			"comment" : [				"I am a refactoring for moving a method down to all direct subclasses.",				"",				"My preconditions verify that this method isn't refered  as a super send in the subclass. And the class defining this method is abstract or not referenced anywhere.",				""			],			"category" : "Refactoring-Core-Refactorings"		},		"ClyMessageBasedQuery" : {			"hash" : 4502272,			"definition" : "ClyMethodQuery subclass: #ClyMessageBasedQuery\r\tinstanceVariableNames: 'selectors'\r\tclassVariableNames: ''\r\tpackage: 'Calypso-SystemQueries-Queries'",			"comment" : [				"I am a root of hierarchy of method queries which uses set of selectors to filter methods.",				"",				"My instances can be created using following methods:",				"",				"\tClyMessageSenders of: #selector.",				"\tClyMessageImplementors of: #selector from: aScope.",				"\tClyMessageSenders ofAny: #(selector1 selector2).",				"\tClyMessageImplementors ofAny: #(selector1 selector2) from: aScope.",				"",				"I provide suitable printing methods and correct comparison implementation.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tselectors:\t\t<Array of<Symbol>>"			],			"category" : "Calypso-SystemQueries-Queries"		}	},	"messages" : {		"exportInFileReference:" : {			"implementors" : {				"MetaSTExporter" : {					"sourceCode" : [						"exportInFileReference: aFileReference",						"",						"\t| json messages |",						"\tjson := aFileReference exists",						"\t\t        ifTrue: [ ",						"\t\t\t        aFileReference readStreamDo: [ :readStream | ",						"\t\t\t\t        STONJSON fromStream: readStream ] ]",						"\t\t        ifFalse: [ ",						"\t\t\t        Dictionary new",						"\t\t\t\t        at: #classes put: Dictionary new;",						"\t\t\t\t        at: #messages put: Dictionary new;",						"\t\t\t\t        yourself ].",						"\t(json at: #messages) valuesDo: [ :aDict | ",						"\t\t(aDict at: #implementors) in: [ :childDict | ",						"\t\t\tchildDict associations",						"\t\t\t\tdo: [ :anAssoc | ",						"\t\t\t\t\t| class |",						"\t\t\t\t\tclass := (anAssoc key endsWith: ' class')",						"\t\t\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t\t\t         | className |",						"\t\t\t\t\t\t\t         className := (anAssoc key splitOn: ' class') first.",						"\t\t\t\t\t\t\t         (Smalltalk at: className asSymbol) class ]",						"\t\t\t\t\t\t         ifFalse: [ Smalltalk at: anAssoc key asSymbol ].",						"\t\t\t\t\tchildDict at: class put: anAssoc value.",						"\t\t\t\t\tchildDict removeKey: anAssoc key ]",						"\t\t\t\tdisplayingProgress: [ :each | 'Reified class ' , each key ] ] ].",						"\tmessages := self valueUsingDictionary: json.",						"\tmessages valuesDo: [ :each | ",						"\t\t(each at: #implementors) in: [ :aDict | ",						"\t\t\teach",						"\t\t\t\tat: #implementors",						"\t\t\t\tput: (aDict associations collect: [ :anAssoc | ",						"\t\t\t\t\t\t anAssoc key name -> anAssoc value ]) asDictionary ] ].",						"\tjson at: #messages put: messages.",						"",						"\taFileReference writeStreamDo: [ :writeStream | ",						"\t\tSTONJSON put: json onStreamPretty: writeStream ].",						"",						"\t^ json"					],					"body" : [						"| json messages |",						"json := aFileReference exists",						"\t        ifTrue: [ ",						"\t\t        aFileReference readStreamDo: [ :readStream | ",						"\t\t\t        STONJSON fromStream: readStream ] ]",						"\t        ifFalse: [ ",						"\t\t        Dictionary new",						"\t\t\t        at: #classes put: Dictionary new;",						"\t\t\t        at: #messages put: Dictionary new;",						"\t\t\t        yourself ].",						"(json at: #messages) valuesDo: [ :aDict | ",						"\t(aDict at: #implementors) in: [ :childDict | ",						"\t\tchildDict associations",						"\t\t\tdo: [ :anAssoc | ",						"\t\t\t\t| class |",						"\t\t\t\tclass := (anAssoc key endsWith: ' class')",						"\t\t\t\t\t         ifTrue: [ ",						"\t\t\t\t\t\t         | className |",						"\t\t\t\t\t\t         className := (anAssoc key splitOn: ' class') first.",						"\t\t\t\t\t\t         (Smalltalk at: className asSymbol) class ]",						"\t\t\t\t\t         ifFalse: [ Smalltalk at: anAssoc key asSymbol ].",						"\t\t\t\tchildDict at: class put: anAssoc value.",						"\t\t\t\tchildDict removeKey: anAssoc key ]",						"\t\t\tdisplayingProgress: [ :each | 'Reified class ' , each key ] ] ].",						"messages := self valueUsingDictionary: json.",						"messages valuesDo: [ :each | ",						"\t(each at: #implementors) in: [ :aDict | ",						"\t\teach",						"\t\t\tat: #implementors",						"\t\t\tput: (aDict associations collect: [ :anAssoc | ",						"\t\t\t\t\t anAssoc key name -> anAssoc value ]) asDictionary ] ].",						"json at: #messages put: messages.",						"",						"aFileReference writeStreamDo: [ :writeStream | ",						"\tSTONJSON put: json onStreamPretty: writeStream ].",						"",						"^ json"					],					"isTestMethod" : false,					"category" : "export",					"comment" : [ ],					"hash" : 20996907,					"argumentNames" : [						"aFileReference"					]				}			},			"senders" : [				"BaselineOfMetaSTExporter>>#scriptExportCoreMessagesForDoc",				"MetaSTExporter>>#exportWithRepositoryPath:ofPackage:"			]		},		"scriptExportCoreMessagesForDoc" : {			"senders" : [				"BaselineOfMetaSTExporter>>#scriptExportCoreMessagesForDoc"			],			"implementors" : {				"BaselineOfMicroKanren" : {					"sourceCode" : [						"scriptExportCoreMessagesForDoc",						"",						"\t<script: 'BaselineOfMicroKanren new scriptExportCoreMessagesForDoc'>",						"\t^ MetaSTExporter new",						"\t\t  selectors:",						"\t\t\t  #( onState: walk: asGoal fail tautology unifyo asReifiedVar",						"\t\t\t     unifyWith: #unifyWith:usingUnifier: #onState:withVars:",						"\t\t\t     #onState:afterPushingGoal: #onState:forGoal:fromConj:",						"\t\t\t     #popGoalFromPathOfState:forConj:",						"\t\t\t     asReifiedWithVarClass: );",						"\t\t  exportWithRepositoryPath: [ :aPath | ",						"\t\t\t  aPath / 'booklet' / 'source' / 'microkanren-core-messages.json' ]",						"\t\t  ofPackage: self class package"					],					"body" : [						"^ MetaSTExporter new",						"\t  selectors:",						"\t\t  #( onState: walk: asGoal fail tautology unifyo asReifiedVar",						"\t\t     unifyWith: #unifyWith:usingUnifier: #onState:withVars:",						"\t\t     #onState:afterPushingGoal: #onState:forGoal:fromConj:",						"\t\t     #popGoalFromPathOfState:forConj:",						"\t\t     asReifiedWithVarClass: );",						"\t  exportWithRepositoryPath: [ :aPath | ",						"\t\t  aPath / 'booklet' / 'source' / 'microkanren-core-messages.json' ]",						"\t  ofPackage: self class package"					],					"isTestMethod" : false,					"category" : "export",					"comment" : [ ],					"hash" : 3309685,					"argumentNames" : [ ]				},				"BaselineOfMetaSTExporter" : {					"sourceCode" : [						"scriptExportCoreMessagesForDoc",						"",						"\t<script:",						"\t'BaselineOfMetaSTExporter new scriptExportCoreMessagesForDoc'>",						"\t^ MetaSTExporter new",						"\t\t  selectors: #( selectors: #exportWithRepositoryPath:ofPackage:",						"\t\t\t     scriptExportCoreMessagesForDoc );",						"\t\t  exportWithRepositoryPath: [ :aPath | ",						"\t\t\t  aPath / 'booklet' / 'source' / 'core-messages.json' ]",						"\t\t  ofPackage: self class package"					],					"body" : [						"^ MetaSTExporter new",						"\t  selectors: #( selectors: #exportWithRepositoryPath:ofPackage:",						"\t\t     scriptExportCoreMessagesForDoc );",						"\t  exportWithRepositoryPath: [ :aPath | ",						"\t\t  aPath / 'booklet' / 'source' / 'core-messages.json' ]",						"\t  ofPackage: self class package"					],					"isTestMethod" : false,					"category" : "export",					"comment" : [ ],					"hash" : 3645045,					"argumentNames" : [ ]				}			}		},		"exportWithRepositoryPath:ofPackage:" : {			"implementors" : {				"MetaSTExporter" : {					"sourceCode" : [						"exportWithRepositoryPath: aBlock ofPackage: aPackage",						"",						"\t| aPath |",						"\taPath := aBlock value:",						"\t\t         (IceRepository registeredRepositoryIncludingPackage:",						"\t\t\t          aPackage) repositoryDirectory asPath.",						"\t^ self exportInFileReference: aPath asFileReference"					],					"body" : [						"| aPath |",						"aPath := aBlock value:",						"\t         (IceRepository registeredRepositoryIncludingPackage:",						"\t\t          aPackage) repositoryDirectory asPath.",						"^ self exportInFileReference: aPath asFileReference"					],					"isTestMethod" : false,					"category" : "export",					"comment" : [ ],					"hash" : 37772572,					"argumentNames" : [						"aBlock",						"aPackage"					]				}			},			"senders" : [				"BaselineOfMetaSTExporter>>#scriptExportCoreMessagesForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"BaselineOfMicroKanren>>#scriptExportSexpTestsForDoc",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc",				"BaselineOfMicroKanren>>#scriptExportCoreMessagesForDoc",				"BaselineOfMicroKanren>>#scriptExportCoreTestsForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverPredicatesForDoc"			]		},		"valueUsingDictionary:" : {			"senders" : [				"BaselineOfMetaSTExporter>>#scriptExportCoreMessagesForDoc",				"MetaSTExporter>>#exportInFileReference:"			],			"implementors" : {				"MetaSTExporter" : {					"sourceCode" : [						"valueUsingDictionary: aDictionary",						"",						"\t| messages classes |",						"\tmessages := Dictionary new.",						"\tselectors",						"\t\tdo: [ :eachSelector | ",						"\t\t\tmessages",						"\t\t\t\tat: eachSelector",						"\t\t\t\tput: (self encodeSelector: eachSelector inDictionary: aDictionary) ]",						"\t\tdisplayingProgress: [ :each | 'Exporting selector: #' , each ].",						"",						"\tclasses := (messages values collect: [ :each | ",						"\t\t            each at: #implementors ]) flatCollect: #keys as: Set.",						"\tclasses",						"\t\tdo: [ :aClass | ",						"\t\t\t(aDictionary at: #classes)",						"\t\t\t\tat: aClass name",						"\t\t\t\tput: (self encodeClass: aClass) ]",						"\t\tdisplayingProgress: [ :aClass | 'Exporting class: ' , aClass name ].",						"",						"\t^ messages"					],					"body" : [						"| messages classes |",						"messages := Dictionary new.",						"selectors",						"\tdo: [ :eachSelector | ",						"\t\tmessages",						"\t\t\tat: eachSelector",						"\t\t\tput: (self encodeSelector: eachSelector inDictionary: aDictionary) ]",						"\tdisplayingProgress: [ :each | 'Exporting selector: #' , each ].",						"",						"classes := (messages values collect: [ :each | each at: #implementors ])",						"\t           flatCollect: #keys",						"\t           as: Set.",						"classes",						"\tdo: [ :aClass | ",						"\t\t(aDictionary at: #classes)",						"\t\t\tat: aClass name",						"\t\t\tput: (self encodeClass: aClass) ]",						"\tdisplayingProgress: [ :aClass | 'Exporting class: ' , aClass name ].",						"",						"^ messages"					],					"isTestMethod" : false,					"category" : "evaluating",					"comment" : [ ],					"hash" : 20997672,					"argumentNames" : [						"aDictionary"					]				}			}		},		"selectors:" : {			"implementors" : {				"CoMockClass" : {					"sourceCode" : [						"selectors: aCollection",						"",						"\t\"Install nil methods just for compatibility\"",						"",						"\taCollection do: [ :k | methodDictionary at: k put: nil ]"					],					"body" : [						"aCollection do: [ :k | methodDictionary at: k put: nil ]"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [						"Install nil methods just for compatibility"					],					"hash" : 20700975,					"argumentNames" : [						"aCollection"					]				},				"RBPushDownMethodRefactoring" : {					"sourceCode" : [						"selectors: aList",						"",						"\tselectors := aList"					],					"body" : [						"selectors := aList"					],					"isTestMethod" : false,					"category" : "transforming",					"comment" : [ ],					"hash" : 21118361,					"argumentNames" : [						"aList"					]				},				"MetaSTExporter" : {					"sourceCode" : [						"selectors: anObject",						"",						"\tselectors := anObject"					],					"body" : [						"selectors := anObject"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20469910,					"argumentNames" : [						"anObject"					]				},				"ExternalBrowser" : {					"sourceCode" : [						"selectors: anObject",						"",						"\tselectors := anObject"					],					"body" : [						"selectors := anObject"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20977105,					"argumentNames" : [						"anObject"					]				},				"ClyMessageBasedQuery" : {					"sourceCode" : [						"selectors: anObject",						"",						"\tselectors := anObject"					],					"body" : [						"selectors := anObject"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 22335384,					"argumentNames" : [						"anObject"					]				},				"RBPullUpMethodRefactoring" : {					"sourceCode" : [						"selectors: aList",						"",						"\tselectors := aList"					],					"body" : [						"selectors := aList"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 21117850,					"argumentNames" : [						"aList"					]				},				"PragmaCollector class" : {					"sourceCode" : [						"selectors: anArray",						"",						"\t\"Create a PragmaCollector that looks for Pragmas with the specified selectors\"",						"",						"\t^ self new selectors: anArray"					],					"body" : [						"^ self new selectors: anArray"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [						"Create a PragmaCollector that looks for Pragmas with the specified selectors"					],					"hash" : 19305021,					"argumentNames" : [						"anArray"					]				},				"PragmaCollector" : {					"sourceCode" : [						"selectors: anArray",						"",						"\tselectors := anArray"					],					"body" : [						"selectors := anArray"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 19305115,					"argumentNames" : [						"anArray"					]				}			},			"senders" : [				"BaselineOfMetaSTExporter>>#scriptExportCoreMessagesForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter01ForDoc",				"BaselineOfMicroKanren>>#scriptExportSexpTestsForDoc",				"BaselineOfMicroKanren>>#scriptExportRBTheoryForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverChapter02ForDoc",				"BaselineOfMicroKanren>>#scriptExportCoreMessagesForDoc",				"BaselineOfMicroKanren>>#scriptExportCoreTestsForDoc",				"BaselineOfMicroKanren>>#scriptExportTheLittleProverPredicatesForDoc",				"ClyMessageBasedQuery class>>#ofAny:",				"CoBasicCompletionTest>>#setUp",				"CoRepeatedHierarchyImplementedSelectorsFetcherTest>>#setUp",				"PragmaCollector class>>#selectors:",				"PragmaCollector class>>#selectors:filter:",				"RBPushDownPreviewPresenter>>#accept",				"RBPushUpPreviewPresenter>>#accept",				"SettingTree>>#acceptableKeywords:"			]		}	}}